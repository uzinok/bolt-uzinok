extends ../../../templates/template.pug

block variables
	//- переменная для template.pug
	include var.pug

block main
	section
		.container
			h2.visually-hidden Вступление
			p Что такое всплывающее модальное окно? Думаю проще разобраться если начать с простого: что такое всплывающее окно? Всплывающее окно это блок который появляется на странице поверх других элементов. Этот блок содержит в себе информацию и/или интерактивные элементы. Еще у этого блока есть возможность его же закрыть.
			p А что же такое модальное окно? Это такое же всплывающее окно, только еще не допускает действия со страницей. То есть до закрытия модального окна на странице нельзя взаимодействовать с интерактивными элементами, нельзя прокрутить страницу.
	section
		.container
			h2 Как сделать всплывающее модальное окно?
			p Есть куча всяких библиотек и плагинов для этого. Но как я замечаю у многих из них есть список недостатков.
			ol
				li Часто страдает доступность:
					ol
						li Маленькая кнопка «закрыть окно»
						li Неправильно оформлена кнопка «закрыть окно»
						li Нет возможности закрыть окно клавишей «esc»
						li При закрытом окне есть доступ с клавиатуры интерактивным элементам окна
						li При открытом окне есть доступ к интерактивным элементам страницы
						li При открытом окне есть скролл у страницы
						li После закрытия модального окна теряется кнопка по которой открыли окно.
				li Визуальные погрешности:
					ol
						li Не всегда есть подложка (или overlay)
						li Часто нет анимации появления окна
				li Производительность часто страдает
					ol
						li После закрытия окна JavaScript прослушивает события (клавиатуры и/или мыши)
			p У каждого элемента списка есть свои последствия. Но можно и самому написать небольшой скрипт для всплывающего модального окна. Без JavaScript тут не обойтись!
	section
		.container
			h2 Как я писал код.
			p Я давно думал написать код модального окна, но не знал какие моменты нужно учитывать. Просмотрел кучу видео, прочел множество статей на эту тему. Больше всего мне понравилось видео на ютубе #[a(href="https://www.youtube.com/watch?v=s6PI8pKQxgo&t=8s", target="_blank", rel="noreferrer noopener") Знакомьтесь, модальное окно, Анна Селезнёва]. Можно сказать что по этому видео я и писал код.
			p Получилось довольно хорошо. И я пользовался им какое-то время, пока не заметил один небольшой вопрос. Этот вопрос заключался в производительности. Код я написал таким образом что его можно обновить и ничего не поломается.
	section
		.container
			h2 Код.
			p Для того что бы написать свой плагин модального всплывающего окна я действовал от простого. Для начала написал HTML разметку.
		section
			.container
				h3 HTML.
				+codeBlock('HTML', '<!-- код -->\n<button class="btn" data-target-popup="popup-1">открыть окно 1</button>\n<!-- код -->\n<div aria-lebelledby="modalTitle" aria-describedby="modalDesc" class="bolt-popup" role="dialog" data-path-popup="popup-1">\n\n  <div class="bolt-popup__container">\n    <button class="bolt-popup__close" aria-label="Close"></button>\n    <h2 id="modalTitle">Это заголовок окна</h2>\n    <p id="modalDesc">Подъехал <span tabindex="2">шофёр</span> на рефрижераторе грузить яйца для обучающихся элитных\n      медиков.</p>\n  </div>\n</div>\n<!-- код -->')
				p У моего кода много атрибутов, но это не просто так! #[code Aria-lebelledby] и #[code aria-describedby] — это заголовок и описание для некоторых скрин-ридеров. #[code role="dialog"] сообщает скрин-ридерам и поисковикам что этот контент ведет себя на странице как модальное окно. Кстати, есть такой тэг #[code dialog]. #[code data-path-popup] это уже мой атрибут, который свяжет модальное окно с кнопкой(если оно есть). Соответственно у кнопки тоже есть атрибут #[code data-target-popup].
		section
			.container
				h3 Стили.
				p Я использую препроцессор Less, он более строгий чем Sass, на мой взгляд))
				+codeBlock('less', `body {\n  // box-sizing: border-box;\n  scrollbar-gutter: stable;\n}\n\n.bolt-popup {\n  // скрываем окно\n  width: 0;\n  height: 0;\n  overflow: hidden;\n  opacity: 0;\n  // добавляем анимацию появления окна\n  transition: opacity 150ms;\n\n  // когда окно открыто\n  &--visible {\n    // прозрачная подложка\n    background-color: rgba(0, 0, 0, 0.2);\n    // позиционируем на весь экран\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    // делаем окно видимым\n    opacity: 1;\n\n    // контент окна распологаем по ценру\n    display: flex;\n    justify-content: center;\n    align-items: center;\n\n    // визуально оаставляем скролл\n    overflow-y: scroll;\n  }\n}\n\n// контент\n.bolt-popup__container {\n  // для кнопки "закрыть"\n  position: relative;\n\n  // для читабельности\n  background-color: #fff;\n  border-radius: 2px;\n  padding: 2em 1em 1em;\n  // что бы не прилипало к краям когда маленький экран\n  margin: auto 15px;\n}\n\n// кнопка закрыть\n.bolt-popup__close {\n  // ставим в правый верхний угол жестко\n  position: absolute;\n  top: -15px;\n  right: -15px;\n\n  // минимальный размер для интеракривных элементов для мобильных устройств\n  width: 48px;\n  height: 48px;\n  padding: 0;\n  box-shadow: none;\n  border: none;\n  background-color: transparent;\n\n  // крестик\n  &::before,\n  &::after {\n    position: absolute;\n    content: '';\n    display: block;\n    width: 20px;\n    height: 2px;\n    background-color: #000;\n    top: 50%;\n    left: 50%;\n  }\n\n  &::before {\n    transform: translate(-50%, -50%) rotate(45deg);\n  }\n\n  &::after {\n    transform: translate(-50%, -50%) rotate(-45deg);\n  }\n}`)
				p Про стили тоже есть что сказать. #[code body] я добавил #[code box-sizing: border-box;] для того что бы при запрете скролла контент не дергался. Для подложки добавил свойство #[code transition: opacity 150ms;] для плавного появления модального окна. Важно заметить что анимирую только свойство #[code opacity] не просто так, а для профилактики непредвиденных обстоятельств. Ведь и размеры и расположение окна могут анимироваться. Тогда окно появляться может не очень красиво. А еще это улучшает производительность сайта. У кнопки «закрыть окно» минимальный размер для мобильных устройств. И крестик написан не иконочными шрифтами или символами, а псевдо-элементами. Иконочные шрифты скрин-ридеры могут не так прочитать, ровно как и html символы. бука «x» или «х» тоже отпадают по этой причине. Но CSS рисунок скрин-ридеры не прочитают, а атрибут #[code aria-label="Close"] все скажет правильно.
		section
			.container
				h3 JavaScript.
				+codeBlock('JS', "class BoltPopup {\n  constructor(popup) {\n    // само окно\n    this.popup = popup\n    // кнопка на которую кликнули для открытия окна\n    this.clickBtn\n    // высота прокрутки страницы при ткрытии окна\n    this.scrollHeight = 0\n    // окно закрыто\n    this.check = false\n\n    // css селектор интерактивных окон\n    this.interactiveCSS = `a[href]:not([tabindex='-1']), area[href]:not([tabindex='-1']), input:not([disabled]):not([tabindex='-1']), select:not([disabled]):not([tabindex='-1']), textarea:not([disabled]):not([tabindex='-1']), button:not([disabled]):not([tabindex='-1']), iframe:not([tabindex='-1']), [tabindex]:not([tabindex='-1']), [contentEditable=true]:not([tabindex='-1'])`\n\n    // добавляем необходимые атрибуты окну и его элементам\n    this.initPopup()\n  }\n\n  initPopup() {\n    // получаем все интерактивные элементы окна\n    let interactiveEl = this.popup.querySelectorAll(this.interactiveCSS);\n\n    this.popup.setAttribute('aria-hidden', 'true');\n\n    // перебирем все интерактивные элементы\n    for (let i = 0; i < interactiveEl.length; i++) {\n      // если есть атрибут tabindex\n      if (interactiveEl[i].getAttribute('tabindex')) {\n        // запоминаем в data-tabindex\n        interactiveEl[i].setAttribute('data-tabindex', interactiveEl[i].getAttribute('tabindex'));\n      }\n      // задаем tabindex -1 что бы исключить из доступа с клавиатуры\n      interactiveEl[i].setAttribute('tabindex', -1);\n      // запоминаем что это элемент окна\n      interactiveEl[i].setAttribute('data-popup', true);\n    }\n\n    // получаем все возможные кнопки для открытия текущего окна\n    let btns = document.querySelectorAll(`[data-target-popup=&quot;${this.popup.getAttribute('data-path-popup')}&quot;]`);\n\n    // в цикле отслеживаем по ним клик и открываем окно\n    for (let i = 0; i < btns.length; i++) {\n      btns[i].addEventListener('click', () => {\n        this.isOpen(btns[i])\n      })\n    }\n  }\n\n  isOpen(clickBtn) {\n    // запоминаем что окно открыто\n    this.check = true;\n    // запоминаем на какую кнопку кликнули\n    this.clickBtn = clickBtn || false;\n    // добавляем кликабельность для overlay\n    this.popup.setAttribute('tabindex', 0);\n    // показываем окно\n    this.popup.classList.add('bolt-popup--visible');\n    this.popup.removeAttribute('aria-hidden');\n\n    // получаем все интерактивные элементы окна\n    let interactiveEl = document.querySelectorAll(this.interactiveCSS);\n\n    for (let i = 0; i < interactiveEl.length; i++) {\n      // если это элемент не всплывающего окна\n      if (!interactiveEl[i].getAttribute('data-popup')) {\n        // если есть атрибут tabindex\n        if (interactiveEl[i].getAttribute('tabindex')) {\n          // запоминаем его в data-tabindex\n          interactiveEl[i].setAttribute('data-tabindex', interactiveEl[i].getAttribute('tabindex'));\n        }\n        // закрываем доступ от клавиатуры\n        interactiveEl[i].setAttribute('tabindex', -1);\n      }\n    }\n\n    // у всех элементов окна удаляем/меняем tabindex -1\n    let interactiveElPopup = this.popup.querySelectorAll('[tabindex=&quot;-1&quot;]');\n    for (let i = 0; i < interactiveElPopup.length; i++) {\n      if (interactiveElPopup[i].getAttribute('data-tabindex')) {\n        interactiveElPopup[i].setAttribute('tabindex', interactiveElPopup[i].getAttribute('data-tabindex'))\n      } else {\n        interactiveElPopup[i].removeAttribute('tabindex');\n      }\n    }\n\n    // на тот случай если body не на всю ширину\n    document.body.style.width = '100%';\n    // высота прокрутки страницы на момент открытия окна\n    this.scrollHeight = window.scrollY || window.pageYOffset;\n    // для фиксации задаем для body\n    document.body.style.top = `-${this.scrollHeight}px`;\n    // если есть полоса прокрутки - компенсируем ее отсутствие внутренним отступом\n    setTimeout(function() {\n      // запрещаем скролл\n      document.body.style.position = &quot;fixed&quot;;\n    }, 0)\n\n    // фокус окну для читалок\n    this.popup.focus();\n\n    // отслеживаем клик на &quot;esc&quot;, клик на overlay, на кнопку закрыть окно\n    document.addEventListener('keydown', this.monitorKeyboard);\n    document.addEventListener('click', this.monitorClick);\n  }\n\n  monitorKeyboard = (event) => {\n    // если кликнули на клавишу &quot;esc&quot; и окно открыто\n    if (event.keyCode == 27) {\n      // закрываем\n      this.isClose();\n    }\n  }\n\n  monitorClick = (event) => {\n    // если кликнули на кнопку &quot;закрыть окно&quot; или на подложку\n    if (\n      event.target == this.popup.querySelector('.bolt-popup__close') ||\n      event.target == this.popup && event.target != this.popup.querySelector('.bolt-popup__container')\n    ) {\n      // закрываем окно\n      this.isClose();\n    }\n  }\n\n  isClose() {\n    // запоминаем что окно закрыто\n    this.check = false;\n    // убираем кликабельность у окна\n    this.popup.removeAttribute('tabindex');\n    // скрываем окно\n    this.popup.classList.remove('bolt-popup--visible');\n    this.popup.setAttribute('aria-hidden', 'true')\n\n    // удаляем tabindex -1 там где не нужен на встранице\n    let interactiveEl = document.querySelectorAll('[tabindex=&quot;-1&quot;]');\n    for (let i = 0; i < interactiveEl.length; i++) {\n      if (interactiveEl[i].getAttribute('data-tabindex') && !interactiveEl[i].getAttribute('data-popup')) {\n        interactiveEl[i].setAttribute('tabindex', interactiveEl[i].getAttribute('data-tabindex'))\n      } else if (!interactiveEl[i].getAttribute('data-popup')) {\n        interactiveEl[i].removeAttribute('tabindex');\n      }\n    }\n\n    // скрываем элементы окна из доступа с клавиатуры\n    let interactiveElPopup = this.popup.querySelectorAll('[data-popup]');\n    for (let i = 0; i < interactiveElPopup.length; i++) {\n      interactiveElPopup[i].setAttribute('tabindex', -1);\n    }\n\n    // у body удаляем лишние стили и возврашаем нужную высоту скролла\n    document.body.style.position = '';\n    document.body.style.width = '';\n\n    window.scrollTo(0, this.scrollHeight);\n    document.body.style.top = '';\n\n    // кнопке по которой открыли окно задаем фокус\n    if (this.clickBtn) this.clickBtn.focus();\n\n    // удаляем слушатели событий\n    document.removeEventListener('keydown', this.monitorKeyboard);\n    document.removeEventListener('click', this.monitorClick);\n  }\n}")
				p Всего лишь модальное окно, но откуда столько строк? Но есть но: большое количество кода — удаление и добавление атрибутов всем интерактивным элементам, да и самому окну. При написании кода необходимо понимать что у клиента может быть слабое устройство, по этому необходимо следить за производительностью. В конце кода я просто удаляю слушатели событий. Некоторые стили я добавляю не через классы (CSS), а при помощи JavaScript. Это связанно с тем что не все можно предугадать заранее. Например отступ справа у #[code body]. На мобильных устройствах, и на некоторых операционных системах вообще не нужен отступ справа, как на виндовс. Код я чрезмерно закомментировал, должно быть все понятно.
				p И последнее для того что бы окно работало необходимо создать объект:
				+codeBlock('JS', `let popup1 = new BoltPopup(document.querySelector('[dada-path-popup="popup-1"]'))`)
				p Кому интересно #[a(href="https://github.com/uzinok/Bolt-popup", target="_blank", rel="noreferrer noopener") исходный код на гитхабе]. Так же там есть ветка модального окна с использованием HTML5 атрибутом #[code dialog]. Ну и на дзен есть видео:
	section
		.container
			h2.visually-hidden видео
			+zen-video("https://dzen.ru/embed/vccEcK8YVm1Y?from_block=partner&from=zen&backoffice=1&mute=1&autoplay=1&tv=0", "https://dzen.ru/video/watch/643f266796e19b34d283c8a6", "img/article/modal_window/video-1")


			//- +codeBlock('', '')
			//- +codeBlock('', '')
			//- +codeBlock('', '')
