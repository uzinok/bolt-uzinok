extends ../templates/template.pug

block variables
	//- переменная для template.pug
	- var pageTitle = "Всплывающие подсказки"
	- var desc = 'Всплывающие подсказки это небольшие окошки информирующие пользователя. Они могут быть разных цветов и сами удаляются через короткий промежуток времени. Цвета...'
	- var heading = 'Всплывающие подсказки (chips/toast)'
	- var idPage = 'chips'
	- var group = 'css'


block main
	section
		.container

			p Всплывающие подсказки это небольшие окошки информирующие пользователя. Они могут быть разных цветов и сами удаляются через короткий промежуток времени. Цвета зависят от того о чем это окошко сообщает. Например, если после отправки данных на сервер все ок, то окошко зеленое. В противном случае красное. Обычно такие окошки располагаются в правом верхнем углу, но на мобильных устройствах в левом нижнем углу. Такое расположение не случайно: меньше мешают обзору контента. А еще эти окошки легко закрыть кликом или тапом.

			figure
				img(src="../img/article/1.webp", alt="Анимированный кот на CSS")
				figcaption Скрин всплывающей подсказки

			p У таких подсказок практически ничего общего с <a href="#">модальными всплывающими окнами</a>. По этой причине код гораздо проще написать.

	section
		.container
			h2 Когда использовать всплывающие подсказки?

			p По сути дела их можно показывать при каждом действии пользователя сайта. Но, как же это бесит! Эти окошки должны появляться только в случае необходимости! Например, когда пользователь хочет получить промо-код, но он отправляется на мэйл пользователя. В таком случае можно показать подсказку с сообщением о том что можно проверить почту. Но не стоит пользователя загружать информацией о том что данные отправляются и т.п.. Если у вас вэб приложение, которое требует постоянного подключения, то тут вам тоже пригодиться подобный плагин. Но только в том случае, когда пользователю нужно сообщить о потере связи.

			p Код я написал довольно быстро, не смотря на то что я верстальщик, а не вэб разработчик. Начал с того что приготовил проект на гитхабе. Потом, записывая видео для своего канала на ютубе, сделал разметку на HTML. Сложного в этой разметке нет. Тут нужен контейнер для чипсов, и пару тройку самих чипсов. Получилось что то вроде этого:

			code.code
				pre
					| &lt;div class="bolt-chips-wrap"&gt;
					|     Экс-граф? Плюш изъят. Бьём чуждый цен хвощ!
					|   &lt;/div&gt;
					|   &lt;!-- ... --&gt;
					| &lt;/div&gt;

			p Классы начинаются на ‘bolt-‘ для того что бы не пересекались стили с другими библиотеками или плагинами. Можно было и другую приставку сделать, но я решил именно эту.

			p У всплывающих подсказок два класса. Первый — задает общие стили: отступы, бордер, стили шрифтов… А второй класс задает цвета. Цвета и названия классов я взял из библиотеки бутстрапа. Это для того что бы было проще запомнить, ведь данные цвета связанны с классами довольно давно.

	section
		.container
			h2 Стили.

			p Со стилями проблем вообще не было. Писал на препроцессоре Less c использованием переменных. Что очень облегчило мне верстку.

			code.code
				pre
					| @primary: #007bff;
					| @secondary: #6c757d;
					| @success: #28a745;
					| @danger: #dc3545;
					| @warning: #ffc107;
					| @info: #17a2b8;
					| @light: #f8f9fa;
					| @dark: #343a40;
					|
					| @color: #212529;
					|
					|// врапер
					|.bolt-chips-wrap {
					|    position: fixed;
					|
					|    bottom: 15px;
					|    left: 15px;
					|    margin-right: 15px;
					|
					|    @media (min-width: 768px) {
					|        bottom: auto;
					|        top: 15px;
					|        left: auto;
					|        right: 15px;
					|        margin-left: 15px;
					|    }
					|
					|    // расположение чипсов
					|    display: flex;
					|    flex-direction: column;
					|    align-items: flex-start;
					|    justify-content: flex-end;
					|
					|    @media (min-width: 768px) {
					|        display: flex;
					|        flex-direction: column;
					|        align-items: flex-end;
					|    }
					|
					|    max-width: 300px;
					|}
					|
					|// чипс
					|.bolt-chips {
					|    padding: 15px;
					|    border-radius: 3px;
					|    margin-top: 15px;
					|
					|    @media (min-width: 768px) {
					|        margin-top: auto;
					|        margin-bottom: 15px;
					|    }
					|
					|    &:last-child {
					|        margin-bottom: 0;
					|    }
					|
					|    font-size: 1.2em;
					|    color: #fff;
					|    font-family: Arial,
					|    Helvetica,
					|    sans-serif;
					|
					|    // модификаторы
					|    &--primary {
					|        background-color: @primary;
					|        border: 1px solid @primary;
					|    }
					|
					|    &--secondary {
					|        background-color: @secondary;
					|        border: 1px solid @secondary;
					|    }
					|
					|    &--success {
					|        background-color: @success;
					|        border: 1px solid @success;
					|    }
					|
					|    &--danger {
					|        background-color: @danger;
					|        border: 1px solid @danger;
					|    }
					|
					|    &--warning {
					|        background-color: @warning;
					|        border: 1px solid @warning;
					|
					|        color: @color;
					|    }
					|
					|    &--info {
					|        background-color: @info;
					|        border: 1px solid @info;
					|    }
					|
					|    &--light {
					|        background-color: @light;
					|        border: 1px solid @dark;
					|
					|        color: @color;
					|    }
					|
					|    &--dark {
					|        background-color: @dark;
					|        border: 1px solid @dark;
					|    }
					|}
			p Тут особо не скажешь ничего по коду, кроме того что уже после записи видео адаптировал чипсы для мобильных устройств.
	section
		.container
			h2 Класс всплывающих подсказок.

			p Всплывающие подсказки можно написать и функционально. Мне то такой код долго не пригодиться))) Но я решил сделать именно плагин, что бы его можно было использовать и переиспользовать в любых проектах. по этому создал класс с конструктором.

			code.code
				pre
					|class BoltCips {
					|    constructor(options) {
					|        this.message = options.message || 'no message';
					|        this.cssClass = options.cssClass || 'bolt-chips--success';
					|        this.delay = options.delay || 5000;
					|
					|        this.wrap = null;
					|        this.chips = null;
					|    }
					|}

			p Первые три переменные получаем из опций переданных классу во время создания объекта. У каждого есть значение по умолчанию. Последние две переменные необходимы для удобной работы с методами.

			p Первый метод, который необходимо вызвать в конструкторе выглядит так:

			code.code
				pre
					|isInit() {
					|    this.wrap = this.getChipsWrap();
					|    this.chips = this.createElem(this.cssClass);
					|
					|    // запуск таймера для удаления чипса через указанный промежуток времени
					|    setTimeout(() => {
					|        this.isClose();
					|    }, this.delay)
					|
					|    this.monitorClick()
					|}

			p Получаем контейнер для чипса, создаем чипс, запускаем таймер для закрытия окна и начинаем слушать клик по чипсу. Про метод <code>this.monitorClick()</code> в конце подробнее расскажу подробнее. Ну а сейчас в очереди <code>this.getChipsWrap()</code>.

			code.code
				pre
					|getChipsWrap() {
					|
					|    if (document.querySelector('.bolt-chips-wrap')) {
					|        return this.wrap = document.querySelector('.bolt-chips-wrap');
					|    }
					|
					|    return this.createElem('bolt-chips-wrap');
					|}

			p На тот случай, если у нас уже есть контейнер, то мы его получаем из DOM. А если нет создаем с помощью следующего метода:

			code.code
				pre
					|createElem(cssClass) {
					|    let elem = document.createElement('div');
					|
					|    // если передан класс "bolt-chips-wrap", создаем врап
					|    if (cssClass == 'bolt-chips-wrap') {
					|        elem.classList.add('bolt-chips-wrap');
					|        document.body.appendChild(elem);
					|        return elem;
					|    }
					|
					|    // либо создаем чипс
					|    elem.innerHTML = this.message;
					|    elem.classList.add('bolt-chips');
					|    elem.classList.add(this.cssClass);
					|    elem.setAttribute('tabindex', 0)
					|
					|    this.wrap.appendChild(elem);
					|    return elem;
					|}

			p Данный метод принимает параметр: класс. Если значение этого параметра равно классу контейнера — создаем контейнер, либо чипс. Тут стоит отметить то, что использовал устаревшие методы для поддержки старых браузеров.

			p И еще один момент: для айос и некоторых других ОС необходим атрибут табиндекс со значением «0». Без этого атрибута не сработало бы закрытие подсказки по клику.

			code.code
				pre
					|isClose() {
					|    this.wrap.removeChild(this.chips);
					|
					|    // удаление слушателя событий
					|    this.chips.removeEventListener('click', this.isClose);
					|
					|    // при необходимости удаляем всрапер из DOM
					|    if (!this.wrap.querySelector('.bolt-chips')) {
					|      document.body.removeChild(this.wrap);
					|    }
					|}

			p Удаляем чипс, если в контейнере нет других всплывающи подсказок — и его удаляем. <br> Удаляем слушателя событий, это необходимо для очистки памяти устройства.

			p И последний метод, который объявлен «не как все»:

			code.code
				pre
					|monitorClick = function () {
					|    this.chips.addEventListener('click', () => {
					|        this.isClose();
					|    });
					|}

			p Данный метод объявлен как ссылка на функцию. Это необходимо для того что бы с помощью <code>removeEventListener</code> можно было удалить слушателя событий.

			p Очень важно обращать внимание на такие мелочи.

			p На устройствах с низкими характеристиками это сильно влияет. Устройство начинает больше греться, «тупить», на мобильных гаджетах быстрее разряжается батарейка.

	section
		.container
			h2 Небольшое дополнение к чипсам.

			p Может я и превращаюсь в перфекциониста, но привык проверять свои работы с помощью скрин-ридеров. И что же я обнаружил? При появлении окошка программа NVDA не отреагировала. Этот вопрос необходимо решить! Тем более что у меня есть проект в котором предусмотрены чипсы оповещающие об ошибках. Но как это сделать? Немного поискав информацию в интернете я нашел решение вопроса.

		.container
			h3 Доступность.

			p Для того, что бы скрин-ридер прочитал сообщение, чипсу нужно добавить атрибут <code>role</code> с одним из значений: <code>alert</code>, <code>status</code>, <code>log</code>, <code>timer</code>, <code>marquee</code> А так же атрибут <code>aria-live</code> для более явного указания важности сообщения. Далее мне осталось решить как добавлять данные атрибуты?

			ul
				li Относительно цвета указать роль и важность сообщения автоматически
				li Дописать возможность добавления этих атрибутов в зависимости от необходимости пользователя

			p Первый вариант очень удобен, не нужно думать когда какой атрибут прописывать. Красное сообщение — значит <code>role="alert"</code> и <code>aria-live="assertive"</code>. При таком раскладе скрин-ридер мгновенно прочтет сообщение об ошибке. Но я выбрал второй вариант по тому что заказчик может попросить красное окошко для оповещений которые не должен читать скрин-ридер.

			p По этой причине и код получился гораздо проще:

			p В конструктор добавил следующие строки:

			code.code
				pre
					| this.role = options.role || null;
					| this.ariaLive = options.ariaLive || null;

			p Ну и немного модифицировал метод <code>createElem()</code> добавив два условия при создании самого чипса. При выполнении которых добавляются атрибуты.

			code.code
				pre
					| if (this.role)
					|   elem.setAttribute('role', this.role)
					| if (this.ariaLive)
					|   elem.setAttribute('aria-live', this.ariaLive)

	section
		.container
			h2 Итог.

			p Получился очень маленький и простой плагин для всплывающих подсказок. При правильном использовании плагина подсказки будут так же доступны скрин-ридерам. Его легко использовать, можно отдельно вызывать методы объекта, у него минимум стилей и JavaScript. Но стили можно переписать без флексов, тогда кода станет еще меньше. Да и с флексами можно уменьшить количество кода зайдя в настройки галпа и уменьшив значение <code>overrideBrowserslist</code>.

			a.demo(href="#") Демо
